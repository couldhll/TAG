<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/PFFile.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/PFFile</TokenIdentifier>
			<Abstract type="html">A file of binary data stored on the Parse servers. This can be a image, video, or anything else
that an application needs to reference in a non-relational way.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>
			
			<NodeRef refid="165"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithData:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data. A name will be assigned to it by the server.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>+ (id)fileWithData:(NSData *)data</Declaration>
			<Parameters>
				<Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of the new PFFile.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A PFFile.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithData:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:data:</TokenIdentifier>
			<Abstract type="html">Creates a file with given data and name.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>+ (id)fileWithName:(NSString *)name data:(NSData *)data</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile.</Abstract>
				</Parameter><Parameter>
					<Name>data</Name>
					<Abstract type="html">The contents of hte new PFFile.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A PFFile.</Abstract></ReturnValue>
			<Anchor>//api/name/fileWithName:data:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFFile/fileWithName:contentsAtPath:</TokenIdentifier>
			<Abstract type="html">Creates a file with the contents of another file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>+ (id)fileWithName:(NSString *)name contentsAtPath:(NSString *)path</Declaration>
			<Parameters>
				<Parameter>
					<Name>name</Name>
					<Abstract type="html">The name of the new PFFile</Abstract>
				</Parameter><Parameter>
					<Name>path</Name>
					<Abstract type="html">The path to the file that will be uploaded to Parse</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fileWithName:contentsAtPath:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setName:</TokenIdentifier>
			<Abstract type="html">The name of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (assign, readonly) NSString *name</Declaration>
			
			
			<Anchor>//api/name/name</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/name</TokenIdentifier>
			<Abstract type="html">The name of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (assign, readonly) NSString *name</Declaration>
			
			
			<Anchor>//api/name/name</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setUrl:</TokenIdentifier>
			<Abstract type="html">The url of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (assign, readonly) NSString *url</Declaration>
			
			
			<Anchor>//api/name/url</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/url</TokenIdentifier>
			<Abstract type="html">The url of the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (assign, readonly) NSString *url</Declaration>
			
			
			<Anchor>//api/name/url</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setIsDirty:</TokenIdentifier>
			<Abstract type="html">Whether the file has been uploaded for the first time.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (readonly) BOOL isDirty</Declaration>
			
			
			<Anchor>//api/name/isDirty</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/isDirty</TokenIdentifier>
			<Abstract type="html">Whether the file has been uploaded for the first time.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (readonly) BOOL isDirty</Declaration>
			
			
			<Anchor>//api/name/isDirty</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/save</TokenIdentifier>
			<Abstract type="html">Saves the file.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (BOOL)save</Declaration>
			
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/save</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/save:</TokenIdentifier>
			<Abstract type="html">Saves the file and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (BOOL)save:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/save:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackground</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackground</Declaration>
			
			
			<Anchor>//api/name/saveInBackground</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously and executes the given block.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackgroundWithBlock:(PFBooleanResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: (BOOL succeeded, NSError *error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously and executes the given resultBlock. Executes the progressBlock periodically with the percent
progress. progressBlock will get called with 100 before resultBlock is called.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackgroundWithBlock:(PFBooleanResultBlock)block progressBlock:(PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: (BOOL succeeded, NSError *error)</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: (int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithBlock:progressBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/saveInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Saves the file asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(NSNumber )result error:(NSError )error. error will be nil on success and set if there was an error. [result boolValue] will tell you whether the call succeeded or not.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/setIsDataAvailable:</TokenIdentifier>
			<Abstract type="html">Whether the data is available in memory or needs to be downloaded.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (readonly) BOOL isDataAvailable</Declaration>
			
			
			<Anchor>//api/name/isDataAvailable</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFFile/isDataAvailable</TokenIdentifier>
			<Abstract type="html">Whether the data is available in memory or needs to be downloaded.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>@property (readonly) BOOL isDataAvailable</Declaration>
			
			
			<Anchor>//api/name/isDataAvailable</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getData</TokenIdentifier>
			<Abstract type="html">Gets the data from cache if available or fetches its contents from the Parse
servers.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (NSData *)getData</Declaration>
			
			<ReturnValue><Abstract type="html">The data. Returns nil if there was an error in fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getData</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStream</TokenIdentifier>
			<Abstract type="html">This method is like getData but avoids ever holding the entire PFFile&apos;s
contents in memory at once. This can help applications with many large PFFiles
avoid memory warnings.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (NSInputStream *)getDataStream</Declaration>
			
			<ReturnValue><Abstract type="html">A stream containing the data. Returns nil if there was an error in
fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataStream</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getData:</TokenIdentifier>
			<Abstract type="html">Gets the data from cache if available or fetches its contents from the Parse
servers. Sets an error if it occurs.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (NSData *)getData:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The data. Returns nil if there was an error in fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getData:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStream:</TokenIdentifier>
			<Abstract type="html">This method is like getData: but avoids ever holding the entire PFFile&apos;s
contents in memory at once. This can help applications with many large PFFiles
avoid memory warnings. Sets an error if it occurs.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (NSInputStream *)getDataStream:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A stream containing the data. Returns nil if there was an error in
fetching.</Abstract></ReturnValue>
			<Anchor>//api/name/getDataStream:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the data from cache if available or fetches its contents
from the Parse servers. Executes the given block.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)getDataInBackgroundWithBlock:(PFDataResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: (NSData result, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStreamInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getDataInBackgroundWithBlock: but avoids ever holding the
entire PFFile&apos;s contents in memory at once. This can help applications with
many large PFFiles avoid memory warnings.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)getDataStreamInBackgroundWithBlock:(PFDataStreamResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block should have the following argument signature: (NSInputStream result, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataStreamInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the data from cache if available or fetches its contents
from the Parse servers. Executes the resultBlock upon
completion or error. Executes the progressBlock periodically with the percent progress. progressBlock will get called with 100 before resultBlock is called.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)getDataInBackgroundWithBlock:(PFDataResultBlock)resultBlock progressBlock:(PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>resultBlock</Name>
					<Abstract type="html">The block should have the following argument signature: (NSData result, NSError error)</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: (int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataInBackgroundWithBlock:progressBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataStreamInBackgroundWithBlock:progressBlock:</TokenIdentifier>
			<Abstract type="html">This method is like getDataInBackgroundWithBlock:progressBlock: but avoids ever
holding the entire PFFile&apos;s contents in memory at once. This can help
applications with many large PFFiles avoid memory warnings.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)getDataStreamInBackgroundWithBlock:(PFDataStreamResultBlock)resultBlock progressBlock:(PFProgressBlock)progressBlock</Declaration>
			<Parameters>
				<Parameter>
					<Name>resultBlock</Name>
					<Abstract type="html">The block should have the following argument signature: (NSInputStream result, NSError error)</Abstract>
				</Parameter><Parameter>
					<Name>progressBlock</Name>
					<Abstract type="html">The block should have the following argument signature: (int percentDone)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataStreamInBackgroundWithBlock:progressBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/getDataInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Asynchronously gets the data from cache if available or fetches its contents
from the Parse servers.</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)getDataInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(NSData )result error:(NSError )error. error will be nil on success and set if there was an error.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/getDataInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFFile/cancel</TokenIdentifier>
			<Abstract type="html">Cancels the current request (whether upload or download of file data).</Abstract>
			<DeclaredIn>PFFile.h</DeclaredIn>			
			
			<Declaration>- (void)cancel</Declaration>
			
			
			<Anchor>//api/name/cancel</Anchor>
		</Token>
		
	</File>
</Tokens>