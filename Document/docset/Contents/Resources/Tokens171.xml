<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/PFObject.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/PFObject</TokenIdentifier>
			<Abstract type="html">A Parse Framework Object that is a local representation of data persisted to the Parse cloud.
This is the main class that is used to interact with objects in your app.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>
			
			<NodeRef refid="171"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/objectWithClassName:</TokenIdentifier>
			<Abstract type="html">Creates a new PFObject with a class name.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (instancetype)objectWithClassName:(NSString *)className</Declaration>
			<Parameters>
				<Parameter>
					<Name>className</Name>
					<Abstract type="html">A class name can be any alphanumeric string that begins with a letter. It represents an object in your app, like a User of a Document.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns the object that is instantiated with the given class name.</Abstract></ReturnValue>
			<Anchor>//api/name/objectWithClassName:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/objectWithoutDataWithClassName:objectId:</TokenIdentifier>
			<Abstract type="html">Creates a reference to an existing PFObject for use in creating associations between PFObjects.  Calling isDataAvailable on this
object will return NO until fetchIfNeeded or refresh has been called.  No network request will be made.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (instancetype)objectWithoutDataWithClassName:(NSString *)className objectId:(NSString *)objectId</Declaration>
			<Parameters>
				<Parameter>
					<Name>className</Name>
					<Abstract type="html">The object&apos;s class.</Abstract>
				</Parameter><Parameter>
					<Name>objectId</Name>
					<Abstract type="html">The object id for the referenced object.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A PFObject without data.</Abstract></ReturnValue>
			<Anchor>//api/name/objectWithoutDataWithClassName:objectId:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/objectWithClassName:dictionary:</TokenIdentifier>
			<Abstract type="html">Creates a new PFObject with a class name, initialized with data constructed from the specified set of objects and keys.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (PFObject *)objectWithClassName:(NSString *)className dictionary:(NSDictionary *)dictionary</Declaration>
			<Parameters>
				<Parameter>
					<Name>className</Name>
					<Abstract type="html">The object&apos;s class.</Abstract>
				</Parameter><Parameter>
					<Name>dictionary</Name>
					<Abstract type="html">An NSDictionary of keys and objects to set on the new PFObject.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A PFObject with the given class name and set with the given data.</Abstract></ReturnValue>
			<Anchor>//api/name/objectWithClassName:dictionary:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/initWithClassName:</TokenIdentifier>
			<Abstract type="html">Initializes a new PFObject with a class name.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (id)initWithClassName:(NSString *)newClassName</Declaration>
			<Parameters>
				<Parameter>
					<Name>newClassName</Name>
					<Abstract type="html">A class name can be any alphanumeric string that begins with a letter. It represents an object in your app, like a User or a Document.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns the object that is instantiated with the given class name.</Abstract></ReturnValue>
			<Anchor>//api/name/initWithClassName:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setParseClassName:</TokenIdentifier>
			<Abstract type="html">The class name of the object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSString *parseClassName</Declaration>
			
			
			<Anchor>//api/name/parseClassName</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFObject/parseClassName</TokenIdentifier>
			<Abstract type="html">The class name of the object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSString *parseClassName</Declaration>
			
			
			<Anchor>//api/name/parseClassName</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setObjectId:</TokenIdentifier>
			<Abstract type="html">The id of the object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain) NSString *objectId</Declaration>
			
			
			<Anchor>//api/name/objectId</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFObject/objectId</TokenIdentifier>
			<Abstract type="html">The id of the object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain) NSString *objectId</Declaration>
			
			
			<Anchor>//api/name/objectId</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setUpdatedAt:</TokenIdentifier>
			<Abstract type="html">When the object was last updated.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain, readonly) NSDate *updatedAt</Declaration>
			
			
			<Anchor>//api/name/updatedAt</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFObject/updatedAt</TokenIdentifier>
			<Abstract type="html">When the object was last updated.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain, readonly) NSDate *updatedAt</Declaration>
			
			
			<Anchor>//api/name/updatedAt</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setCreatedAt:</TokenIdentifier>
			<Abstract type="html">When the object was created.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain, readonly) NSDate *createdAt</Declaration>
			
			
			<Anchor>//api/name/createdAt</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFObject/createdAt</TokenIdentifier>
			<Abstract type="html">When the object was created.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain, readonly) NSDate *createdAt</Declaration>
			
			
			<Anchor>//api/name/createdAt</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setACL:</TokenIdentifier>
			<Abstract type="html">The ACL for this object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain) PFACL *ACL</Declaration>
			
			
			<Anchor>//api/name/ACL</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/PFObject/ACL</TokenIdentifier>
			<Abstract type="html">The ACL for this object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, retain) PFACL *ACL</Declaration>
			
			
			<Anchor>//api/name/ACL</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/allKeys</TokenIdentifier>
			<Abstract type="html">Returns an array of the keys contained in this object. This does not include
createdAt, updatedAt, authData, or objectId. It does include things like username
and ACL.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)allKeys</Declaration>
			
			
			<Anchor>//api/name/allKeys</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/objectForKey:</TokenIdentifier>
			<Abstract type="html">Returns the object associated with a given key.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (id)objectForKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>key</Name>
					<Abstract type="html">The key that the object is associated with.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The value associated with the given key, or nil if no value is associated with key.</Abstract></ReturnValue>
			<Anchor>//api/name/objectForKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setObject:forKey:</TokenIdentifier>
			<Abstract type="html">Sets the object associated with a given key.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)setObject:(id)object forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>object</Name>
					<Abstract type="html">The object.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/setObject:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/removeObjectForKey:</TokenIdentifier>
			<Abstract type="html">Unsets a key on the object.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)removeObjectForKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/removeObjectForKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/objectForKeyedSubscript:</TokenIdentifier>
			<Abstract type="html">* In LLVM 4.0 (XCode 4.5) or higher allows myPFObject[key].</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (id)objectForKeyedSubscript:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/objectForKeyedSubscript:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/setObject:forKeyedSubscript:</TokenIdentifier>
			<Abstract type="html">* In LLVM 4.0 (XCode 4.5) or higher allows myObject[key] = value</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)setObject:(id)object forKeyedSubscript:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>object</Name>
					<Abstract type="html">The object.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/setObject:forKeyedSubscript:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/relationforKey:</TokenIdentifier>
			<Abstract type="html">Returns the relation object associated with the given key</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (PFRelation *)relationforKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>key</Name>
					<Abstract type="html">The key that the relation is associated with.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/relationforKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/addObject:forKey:</TokenIdentifier>
			<Abstract type="html">Adds an object to the end of the array associated with a given key.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)addObject:(id)object forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>object</Name>
					<Abstract type="html">The object to add.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/addObject:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/addObjectsFromArray:forKey:</TokenIdentifier>
			<Abstract type="html">Adds the objects contained in another array to the end of the array associated
with a given key.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)addObjectsFromArray:(NSArray *)objects forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to add.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/addObjectsFromArray:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/addUniqueObject:forKey:</TokenIdentifier>
			<Abstract type="html">Adds an object to the array associated with a given key, only if it is not
already present in the array. The position of the insert is not guaranteed.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)addUniqueObject:(id)object forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>object</Name>
					<Abstract type="html">The object to add.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/addUniqueObject:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/addUniqueObjectsFromArray:forKey:</TokenIdentifier>
			<Abstract type="html">Adds the objects contained in another array to the array associated with
a given key, only adding elements which are not already present in the array.
The position of the insert is not guaranteed.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)addUniqueObjectsFromArray:(NSArray *)objects forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to add.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/addUniqueObjectsFromArray:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/removeObject:forKey:</TokenIdentifier>
			<Abstract type="html">Removes all occurrences of an object from the array associated with a given
key.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)removeObject:(id)object forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>object</Name>
					<Abstract type="html">The object to remove.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/removeObject:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/removeObjectsInArray:forKey:</TokenIdentifier>
			<Abstract type="html">Removes all occurrences of the objects contained in another array from the
array associated with a given key.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)removeObjectsInArray:(NSArray *)objects forKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to remove.</Abstract>
				</Parameter><Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/removeObjectsInArray:forKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/incrementKey:</TokenIdentifier>
			<Abstract type="html">Increments the given key by 1.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)incrementKey:(NSString *)key</Declaration>
			<Parameters>
				<Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/incrementKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/incrementKey:byAmount:</TokenIdentifier>
			<Abstract type="html">Increments the given key by a number.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)incrementKey:(NSString *)key byAmount:(NSNumber *)amount</Declaration>
			<Parameters>
				<Parameter>
					<Name>key</Name>
					<Abstract type="html">The key.</Abstract>
				</Parameter><Parameter>
					<Name>amount</Name>
					<Abstract type="html">The amount to increment.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/incrementKey:byAmount:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/save</TokenIdentifier>
			<Abstract type="html">Saves the PFObject.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (BOOL)save</Declaration>
			
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/save</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/save:</TokenIdentifier>
			<Abstract type="html">Saves the PFObject and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (BOOL)save:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/save:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/saveInBackground</TokenIdentifier>
			<Abstract type="html">Saves the PFObject asynchronously.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackground</Declaration>
			
			
			<Anchor>//api/name/saveInBackground</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/saveInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Saves the PFObject asynchronously and executes the given callback block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackgroundWithBlock:(PFBooleanResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (BOOL succeeded, NSError *error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/saveInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Saves the PFObject asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)saveInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(NSNumber )result error:(NSError )error. error will be nil on success and set if there was an error. [result boolValue] will tell you whether the call succeeded or not.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/saveEventually</TokenIdentifier>
			<Abstract type="html">saveEventually:</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instm/PFObject/saveEventually:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>- (void)saveEventually</Declaration>
			
			
			<Anchor>//api/name/saveEventually</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/saveEventually:</TokenIdentifier>
			<Abstract type="html">Saves this object to the server at some unspecified time in the future, even if Parse is currently inaccessible.
Use this when you may not have a solid network connection, and don&apos;t need to know when the save completes.
If there is some problem with the object such that it can&apos;t be saved, it will be silently discarded.  If the save
completes successfully while the object is still in memory, then callback will be called.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)saveEventually:(PFBooleanResultBlock)callback</Declaration>
			
			
			<Anchor>//api/name/saveEventually:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/saveAll:</TokenIdentifier>
			<Abstract type="html">Saves a collection of objects all at once.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)saveAll:(NSArray *)objects</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to save.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/saveAll:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/saveAll:error:</TokenIdentifier>
			<Abstract type="html">Saves a collection of objects all at once and sets an error if necessary.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)saveAll:(NSArray *)objects error:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to save.</Abstract>
				</Parameter><Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the save succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/saveAll:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/saveAllInBackground:</TokenIdentifier>
			<Abstract type="html">Saves a collection of objects all at once asynchronously.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)saveAllInBackground:(NSArray *)objects</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to save.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveAllInBackground:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/saveAllInBackground:block:</TokenIdentifier>
			<Abstract type="html">Saves a collection of objects all at once asynchronously and the block when done.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)saveAllInBackground:(NSArray *)objects block:(PFBooleanResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to save.</Abstract>
				</Parameter><Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (BOOL succeeded, NSError *error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveAllInBackground:block:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/saveAllInBackground:target:selector:</TokenIdentifier>
			<Abstract type="html">Saves a collection of objects all at once asynchronously and calls a callback when done.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)saveAllInBackground:(NSArray *)objects target:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to save.</Abstract>
				</Parameter><Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithError:(NSError *)error. error will be nil on success and set if there was an error.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/saveAllInBackground:target:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/deleteAll:</TokenIdentifier>
			<Abstract type="html">Deletes a collection of objects all at once.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)deleteAll:(NSArray *)objects</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to delete.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the delete succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/deleteAll:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/deleteAll:error:</TokenIdentifier>
			<Abstract type="html">Deletes a collection of objects all at once and sets an error if necessary.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)deleteAll:(NSArray *)objects error:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to delete.</Abstract>
				</Parameter><Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the delete succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/deleteAll:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/deleteAllInBackground:</TokenIdentifier>
			<Abstract type="html">Deletes a collection of objects all at once asynchronously.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)deleteAllInBackground:(NSArray *)objects</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to delete.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/deleteAllInBackground:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/deleteAllInBackground:block:</TokenIdentifier>
			<Abstract type="html">Deletes a collection of objects all at once asynchronously and the block when done.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)deleteAllInBackground:(NSArray *)objects block:(PFBooleanResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to delete.</Abstract>
				</Parameter><Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (BOOL succeeded, NSError *error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/deleteAllInBackground:block:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/deleteAllInBackground:target:selector:</TokenIdentifier>
			<Abstract type="html">Deletes a collection of objects all at once asynchronously and calls a callback when done.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)deleteAllInBackground:(NSArray *)objects target:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The array of objects to delete.</Abstract>
				</Parameter><Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithError:(NSError *)error. error will be nil on success and set if there was an error.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/deleteAllInBackground:target:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/isDataAvailable</TokenIdentifier>
			<Abstract type="html">Gets whether the PFObject has been fetched.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isDataAvailable</Declaration>
			
			<ReturnValue><Abstract type="html">YES if the PFObject is new or has been fetched or refreshed.  NO otherwise.</Abstract></ReturnValue>
			<Anchor>//api/name/isDataAvailable</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/refresh</TokenIdentifier>
			<Abstract type="html">Refreshes the PFObject with the current data from the server.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)refresh</Declaration>
			
			
			<Anchor>//api/name/refresh</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/refresh:</TokenIdentifier>
			<Abstract type="html">Refreshes the PFObject with the current data from the server and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)refresh:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/refresh:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/refreshInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Refreshes the PFObject asynchronously and executes the given callback block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)refreshInBackgroundWithBlock:(PFObjectResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (PFObject object, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/refreshInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/refreshInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Refreshes the PFObject asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)refreshInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The target on which the selector will be called.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(PFObject )refreshedObject error:(NSError )error. error will be nil on success and set if there was an error. refreshedObject will be the PFObject with the refreshed data.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/refreshInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetch</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject with the current data from the server.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)fetch</Declaration>
			
			
			<Anchor>//api/name/fetch</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetch:</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject with the current data from the server and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)fetch:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetch:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetchIfNeeded</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject&apos;s data from the server if isDataAvailable is false.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (PFObject *)fetchIfNeeded</Declaration>
			
			
			<Anchor>//api/name/fetchIfNeeded</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetchIfNeeded:</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject&apos;s data from the server if isDataAvailable is false.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (PFObject *)fetchIfNeeded:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchIfNeeded:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetchInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject asynchronously and executes the given callback block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)fetchInBackgroundWithBlock:(PFObjectResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (PFObject object, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetchInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)fetchInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The target on which the selector will be called.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(PFObject )refreshedObject error:(NSError )error. error will be nil on success and set if there was an error. refreshedObject will be the PFObject with the refreshed data.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetchIfNeededInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject&apos;s data asynchronously if isDataAvailable is false, then calls the callback block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)fetchIfNeededInBackgroundWithBlock:(PFObjectResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute.  The block should have the following argument signature: (PFObject object, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchIfNeededInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/fetchIfNeededInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Fetches the PFObject&apos;s data asynchronously if isDataAvailable is false, then calls the callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)fetchIfNeededInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The target on which the selector will be called.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call.  It should have the following signature: (void)callbackWithResult:(PFObject )fetchedObject error:(NSError )error. error will be nil on success and set if there was an error.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchIfNeededInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAll:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAll:(NSArray *)objects</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAll:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAll:error:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAll:(NSArray *)objects error:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter><Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set  if necessary</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAll:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAllIfNeeded:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAllIfNeeded:(NSArray *)objects</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAllIfNeeded:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAllIfNeeded:error:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAllIfNeeded:(NSArray *)objects error:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter><Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set  if necessary</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAllIfNeeded:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAllInBackground:block:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server asynchronously and calls the given block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAllInBackground:(NSArray *)objects block:(PFArrayResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter><Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (NSArray objects, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAllInBackground:block:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAllInBackground:target:selector:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAllInBackground:(NSArray *)objects target:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter><Parameter>
					<Name>target</Name>
					<Abstract type="html">The target on which the selector will be called.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(NSArray )fetchedObjects error:(NSError )error. error will be nil on success and set if there was an error. fetchedObjects will the array of PFObjects that were fetched.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAllInBackground:target:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAllIfNeededInBackground:block:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server asynchronously and calls the given block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAllIfNeededInBackground:(NSArray *)objects block:(PFArrayResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter><Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (NSArray objects, NSError error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAllIfNeededInBackground:block:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/fetchAllIfNeededInBackground:target:selector:</TokenIdentifier>
			<Abstract type="html">Fetches all of the PFObjects with the current data from the server asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>+ (void)fetchAllIfNeededInBackground:(NSArray *)objects target:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>objects</Name>
					<Abstract type="html">The list of objects to fetch.</Abstract>
				</Parameter><Parameter>
					<Name>target</Name>
					<Abstract type="html">The target on which the selector will be called.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(NSArray )fetchedObjects error:(NSError )error. error will be nil on success and set if there was an error. fetchedObjects will the array of PFObjects
that were fetched.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/fetchAllIfNeededInBackground:target:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/delete</TokenIdentifier>
			<Abstract type="html">Deletes the PFObject.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (BOOL)delete</Declaration>
			
			<ReturnValue><Abstract type="html">Returns whether the delete succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/delete</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/delete:</TokenIdentifier>
			<Abstract type="html">Deletes the PFObject and sets an error if it occurs.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (BOOL)delete:(NSError **)error</Declaration>
			<Parameters>
				<Parameter>
					<Name>error</Name>
					<Abstract type="html">Pointer to an NSError that will be set if necessary.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">Returns whether the delete succeeded.</Abstract></ReturnValue>
			<Anchor>//api/name/delete:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/deleteInBackground</TokenIdentifier>
			<Abstract type="html">Deletes the PFObject asynchronously.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)deleteInBackground</Declaration>
			
			
			<Anchor>//api/name/deleteInBackground</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/deleteInBackgroundWithBlock:</TokenIdentifier>
			<Abstract type="html">Deletes the PFObject asynchronously and executes the given callback block.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)deleteInBackgroundWithBlock:(PFBooleanResultBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to execute. The block should have the following argument signature: (BOOL succeeded, NSError *error)</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/deleteInBackgroundWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/deleteInBackgroundWithTarget:selector:</TokenIdentifier>
			<Abstract type="html">Deletes the PFObject asynchronously and calls the given callback.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)deleteInBackgroundWithTarget:(id)target selector:(SEL)selector</Declaration>
			<Parameters>
				<Parameter>
					<Name>target</Name>
					<Abstract type="html">The object to call selector on.</Abstract>
				</Parameter><Parameter>
					<Name>selector</Name>
					<Abstract type="html">The selector to call. It should have the following signature: (void)callbackWithResult:(NSNumber )result error:(NSError )error. error will be nil on success and set if there was an error. [result boolValue] will tell you whether the call succeeded or not.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/deleteInBackgroundWithTarget:selector:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/deleteEventually</TokenIdentifier>
			<Abstract type="html">Deletes this object from the server at some unspecified time in the future, even if Parse is currently inaccessible.
Use this when you may not have a solid network connection, and don&apos;t need to know when the delete completes.
If there is some problem with the object such that it can&apos;t be deleted, the request will be silently discarded.</Abstract>
			<DeclaredIn>PFObject.h</DeclaredIn>			
			
			<Declaration>- (void)deleteEventually</Declaration>
			
			
			<Anchor>//api/name/deleteEventually</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/PFObject/init</TokenIdentifier>
			<Abstract type="html">Designated initializer for subclasses.
This method can only be called on subclasses which conform to PFSubclassing.
This method should not be overridden.</Abstract>
			<DeclaredIn>PFObject+Subclass.h</DeclaredIn>			
			
			<Declaration>- (id)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/object</TokenIdentifier>
			<Abstract type="html">Creates an instance of the registered subclass with this class&apos;s parseClassName.
This helps a subclass ensure that it can be subclassed itself. For example, [PFUser object] will
return a MyUser object if MyUser is a registered subclass of PFUser. For this reason, [MyClass object] is
preferred to [[MyClass alloc] init].
This method can only be called on subclasses which conform to PFSubclassing.
  A default implementation is provided by PFObject which should always be sufficient.</Abstract>
			<DeclaredIn>PFObject+Subclass.h</DeclaredIn>			
			
			<Declaration>+ (instancetype)object</Declaration>
			
			
			<Anchor>//api/name/object</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/objectWithoutDataWithObjectId:</TokenIdentifier>
			<Abstract type="html">Creates a reference to an existing PFObject for use in creating associations between PFObjects.  Calling isDataAvailable on this
object will return NO until fetchIfNeeded or refresh has been called.  No network request will be made.
This method can only be called on subclasses which conform to PFSubclassing.
A default implementation is provided by PFObject which should always be sufficient.</Abstract>
			<DeclaredIn>PFObject+Subclass.h</DeclaredIn>			
			
			<Declaration>+ (id)objectWithoutDataWithObjectId:(NSString *)objectId</Declaration>
			<Parameters>
				<Parameter>
					<Name>objectId</Name>
					<Abstract type="html">The object id for the referenced object.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A PFObject without data.</Abstract></ReturnValue>
			<Anchor>//api/name/objectWithoutDataWithObjectId:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/registerSubclass</TokenIdentifier>
			<Abstract type="html">Registers an Objective-C class for Parse to use for representing a given Parse class.
Once this is called on a PFObject subclass, any PFObject Parse creates with a class
name matching [self parseClassName] will be an instance of subclass.
This method can only be called on subclasses which conform to PFSubclassing.
A default implementation is provided by PFObject which should always be sufficient.</Abstract>
			<DeclaredIn>PFObject+Subclass.h</DeclaredIn>			
			
			<Declaration>+ (void)registerSubclass</Declaration>
			
			
			<Anchor>//api/name/registerSubclass</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/PFObject/query</TokenIdentifier>
			<Abstract type="html">Returns a query for objects of type parseClassName.
This method can only be called on subclasses which conform to PFSubclassing.
A default implementation is provided by PFObject which should always be sufficient.</Abstract>
			<DeclaredIn>PFObject+Subclass.h</DeclaredIn>			
			
			<Declaration>+ (PFQuery *)query</Declaration>
			
			
			<Anchor>//api/name/query</Anchor>
		</Token>
		
	</File>
</Tokens>